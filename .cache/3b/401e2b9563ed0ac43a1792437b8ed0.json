{"id":"../node_modules/airbnb-prop-types/build/sequenceOf.js","dependencies":[{"name":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/sequenceOf.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/tspanu/Code/react-course-projects/expensify-app/package.json","includedInParent":true,"mtime":1543301183752},{"name":"/Users/tspanu/Code/react-course-projects/expensify-app/.babelrc","includedInParent":true,"mtime":1543300678905},{"name":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/package.json","includedInParent":true,"mtime":1542929074985},{"name":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/.babelrc","includedInParent":true,"mtime":499162500000},{"name":"object.assign","loc":{"line":6,"column":22},"parent":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/sequenceOf.js","resolved":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/object.assign/index.js"},{"name":"prop-types","loc":{"line":10,"column":25},"parent":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/sequenceOf.js","resolved":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/prop-types/index.js"},{"name":"./and","loc":{"line":12,"column":19},"parent":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/sequenceOf.js","resolved":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/and.js"},{"name":"./between","loc":{"line":16,"column":23},"parent":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/sequenceOf.js","resolved":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/between.js"},{"name":"./nonNegativeInteger","loc":{"line":20,"column":34},"parent":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/sequenceOf.js","resolved":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/nonNegativeInteger.js"},{"name":"./object","loc":{"line":24,"column":23},"parent":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/sequenceOf.js","resolved":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/object.js"},{"name":"./withShape","loc":{"line":28,"column":25},"parent":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/sequenceOf.js","resolved":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/withShape.js"},{"name":"./helpers/typeOf","loc":{"line":32,"column":22},"parent":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/sequenceOf.js","resolved":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/helpers/typeOf.js"},{"name":"./helpers/wrapValidator","loc":{"line":36,"column":29},"parent":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/sequenceOf.js","resolved":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/helpers/wrapValidator.js"}],"generated":{"js":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports['default'] = sequenceOfValidator;\n\nvar _object = require('object.assign');\n\nvar _object2 = _interopRequireDefault(_object);\n\nvar _propTypes = require('prop-types');\n\nvar _and = require('./and');\n\nvar _and2 = _interopRequireDefault(_and);\n\nvar _between = require('./between');\n\nvar _between2 = _interopRequireDefault(_between);\n\nvar _nonNegativeInteger = require('./nonNegativeInteger');\n\nvar _nonNegativeInteger2 = _interopRequireDefault(_nonNegativeInteger);\n\nvar _object3 = require('./object');\n\nvar _object4 = _interopRequireDefault(_object3);\n\nvar _withShape = require('./withShape');\n\nvar _withShape2 = _interopRequireDefault(_withShape);\n\nvar _typeOf = require('./helpers/typeOf');\n\nvar _typeOf2 = _interopRequireDefault(_typeOf);\n\nvar _wrapValidator = require('./helpers/wrapValidator');\n\nvar _wrapValidator2 = _interopRequireDefault(_wrapValidator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar minValidator = _nonNegativeInteger2['default'];\nvar maxValidator = (0, _and2['default'])([_nonNegativeInteger2['default'], (0, _between2['default'])({ gte: 1 })]);\n\nfunction validateRange(min, max) {\n  if (typeof max !== 'number' || typeof min !== 'number') {\n    return null; // no additional checking needed unless both are present\n  }\n\n  if (min <= max) {\n    return null;\n  }\n  return new RangeError('min must be less than or equal to max');\n}\n\nvar specifierShape = {\n  validator: function () {\n    function validator(props, propName) {\n      var propValue = props[propName];\n\n      if (typeof propValue !== 'function') {\n        return new TypeError('\"validator\" must be a propType validator function');\n      }\n      return null;\n    }\n\n    return validator;\n  }(),\n  min: function () {\n    function min(props, propName) {\n      return minValidator(props, propName) || validateRange(props.min, props.max);\n    }\n\n    return min;\n  }(),\n  max: function () {\n    function max(props, propName) {\n      return maxValidator(props, propName) || validateRange(props.min, props.max);\n    }\n\n    return max;\n  }()\n};\n\nfunction getMinMax(_ref) {\n  var min = _ref.min,\n      max = _ref.max;\n\n  var minimum = void 0;\n  var maximum = void 0;\n  if (typeof min !== 'number' && typeof max !== 'number') {\n    // neither provided, default to \"1\"\n    minimum = 1;\n    maximum = 1;\n  } else {\n    minimum = typeof min === 'number' ? min : 1;\n    maximum = typeof max === 'number' ? max : Infinity;\n  }\n  return { minimum: minimum, maximum: maximum };\n}\n\nfunction chunkByType(items) {\n  var chunk = [];\n  var lastType = void 0;\n  return items.reduce(function (chunks, item) {\n    var itemType = (0, _typeOf2['default'])(item);\n    if (!lastType || itemType === lastType) {\n      chunk.push(item);\n    } else {\n      chunks.push(chunk);\n      chunk = [item];\n    }\n    lastType = itemType;\n    return chunks;\n  }, []).concat(chunk.length > 0 ? [chunk] : []);\n}\n\nfunction validateChunks(specifiers, props, propName, componentName) {\n  var items = props[propName];\n\n  var chunks = chunkByType(items);\n\n  for (var _len = arguments.length, rest = Array(_len > 4 ? _len - 4 : 0), _key = 4; _key < _len; _key++) {\n    rest[_key - 4] = arguments[_key];\n  }\n\n  for (var i = 0; i < specifiers.length; i += 1) {\n    var _specifiers$i = specifiers[i],\n        validator = _specifiers$i.validator,\n        min = _specifiers$i.min,\n        max = _specifiers$i.max;\n\n    var _getMinMax = getMinMax({ min: min, max: max }),\n        minimum = _getMinMax.minimum,\n        maximum = _getMinMax.maximum;\n\n    if (chunks.length === 0 && minimum === 0) {\n      // no chunks left, but this specifier does not require any items\n      continue; // eslint-disable-line no-continue\n    }\n\n    var arrayOfValidator = (0, _propTypes.arrayOf)(validator).isRequired;\n\n    var chunk = chunks.shift(); // extract the next chunk to test\n\n    var chunkError = arrayOfValidator.apply(undefined, [(0, _object2['default'])({}, props, _defineProperty({}, propName, chunk)), propName, componentName].concat(rest));\n\n    if (chunkError) {\n      // this chunk is invalid\n      if (minimum === 0) {\n        // but, specifier has a min of 0 and can be skipped\n        chunks.unshift(chunk); // put the chunk back, for the next iteration\n        continue; // eslint-disable-line no-continue\n      }\n      return chunkError;\n    }\n\n    // chunk is valid!\n\n    if (chunk.length < minimum) {\n      return new RangeError(String(componentName) + ': specifier index ' + i + ' requires a minimum of ' + String(min) + ' items, but only has ' + String(chunk.length) + '.');\n    }\n\n    if (chunk.length > maximum) {\n      return new RangeError(String(componentName) + ': specifier index ' + i + ' requires a maximum of ' + String(max) + ' items, but has ' + String(chunk.length) + '.');\n    }\n  }\n\n  if (chunks.length > 0) {\n    return new TypeError(String(componentName) + ': after all ' + String(specifiers.length) + ' specifiers matched, ' + String(chunks.length) + ' types of items were remaining.');\n  }\n\n  return null;\n}\n\nvar specifierValidator = (0, _withShape2['default'])((0, _object4['default'])(), specifierShape).isRequired;\n\nfunction sequenceOfValidator() {\n  for (var _len2 = arguments.length, specifiers = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    specifiers[_key2] = arguments[_key2];\n  }\n\n  if (specifiers.length === 0) {\n    throw new RangeError('sequenceOf: at least one specifier is required');\n  }\n\n  var errors = specifiers.map(function (specifier, i) {\n    return specifierValidator({ specifier: specifier }, 'specifier', 'sequenceOf specifier', 'suequenceOf specifier, index ' + String(i), 'specifier, index ' + String(i));\n  });\n  if (errors.some(Boolean)) {\n    throw new TypeError('\\n      sequenceOf: all specifiers must match the appropriate shape.\\n\\n      Errors:\\n        ' + String(errors.map(function (e, i) {\n      return ' - Argument index ' + String(i) + ': ' + String(e.message);\n    }).join(',\\n        ')) + '\\n    ');\n  }\n\n  var validator = function () {\n    function sequenceOf(props, propName) {\n      var propValue = props[propName];\n\n\n      if (propValue == null) {\n        return null;\n      }\n\n      for (var _len3 = arguments.length, rest = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        rest[_key3 - 2] = arguments[_key3];\n      }\n\n      var error = _propTypes.array.apply(undefined, [props, propName].concat(rest));\n      if (error) {\n        return error;\n      }\n\n      return validateChunks.apply(undefined, [specifiers, props, propName].concat(rest));\n    }\n\n    return sequenceOf;\n  }();\n\n  validator.isRequired = function () {\n    function sequenceOfRequired(props, propName, componentName) {\n      for (var _len4 = arguments.length, rest = Array(_len4 > 3 ? _len4 - 3 : 0), _key4 = 3; _key4 < _len4; _key4++) {\n        rest[_key4 - 3] = arguments[_key4];\n      }\n\n      var error = _propTypes.array.isRequired.apply(_propTypes.array, [props, propName, componentName].concat(rest));\n      if (error) {\n        return error;\n      }\n\n      return validateChunks.apply(undefined, [specifiers, props, propName, componentName].concat(rest));\n    }\n\n    return sequenceOfRequired;\n  }();\n\n  return (0, _wrapValidator2['default'])(validator, 'sequenceOf', specifiers);\n}\n","map":{"version":3,"sources":["../src/sequenceOf.js"],"names":["sequenceOfValidator","minValidator","nonNegativeInteger","maxValidator","gte","validateRange","min","max","RangeError","specifierShape","validator","props","propName","propValue","TypeError","getMinMax","minimum","maximum","Infinity","chunkByType","items","chunk","lastType","reduce","chunks","item","itemType","push","concat","length","validateChunks","specifiers","componentName","rest","i","arrayOfValidator","isRequired","shift","chunkError","unshift","specifierValidator","errors","map","specifier","some","Boolean","e","message","join","sequenceOf","error","array","sequenceOfRequired"],"mappings":"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","file":"sequenceOf.js","sourcesContent":["import { array, arrayOf } from 'prop-types';\n\nimport and from './and';\nimport between from './between';\nimport nonNegativeInteger from './nonNegativeInteger';\nimport object from './object';\nimport withShape from './withShape';\nimport typeOf from './helpers/typeOf';\nimport wrapValidator from './helpers/wrapValidator';\n\nconst minValidator = nonNegativeInteger;\nconst maxValidator = and([nonNegativeInteger, between({ gte: 1 })]);\n\nfunction validateRange(min, max) {\n  if (typeof max !== 'number' || typeof min !== 'number') {\n    return null; // no additional checking needed unless both are present\n  }\n\n  if (min <= max) {\n    return null;\n  }\n  return new RangeError('min must be less than or equal to max');\n}\n\nconst specifierShape = {\n  validator(props, propName) {\n    const { [propName]: propValue } = props;\n    if (typeof propValue !== 'function') {\n      return new TypeError('\"validator\" must be a propType validator function');\n    }\n    return null;\n  },\n\n  min(props, propName) {\n    return minValidator(props, propName) || validateRange(props.min, props.max);\n  },\n\n  max(props, propName) {\n    return maxValidator(props, propName) || validateRange(props.min, props.max);\n  },\n};\n\nfunction getMinMax({ min, max }) {\n  let minimum;\n  let maximum;\n  if (typeof min !== 'number' && typeof max !== 'number') {\n    // neither provided, default to \"1\"\n    minimum = 1;\n    maximum = 1;\n  } else {\n    minimum = typeof min === 'number' ? min : 1;\n    maximum = typeof max === 'number' ? max : Infinity;\n  }\n  return { minimum, maximum };\n}\n\nfunction chunkByType(items) {\n  let chunk = [];\n  let lastType;\n  return items.reduce((chunks, item) => {\n    const itemType = typeOf(item);\n    if (!lastType || itemType === lastType) {\n      chunk.push(item);\n    } else {\n      chunks.push(chunk);\n      chunk = [item];\n    }\n    lastType = itemType;\n    return chunks;\n  }, []).concat(chunk.length > 0 ? [chunk] : []);\n}\n\nfunction validateChunks(specifiers, props, propName, componentName, ...rest) {\n  const { [propName]: items } = props;\n  const chunks = chunkByType(items);\n\n  for (let i = 0; i < specifiers.length; i += 1) {\n    const { validator, min, max } = specifiers[i];\n\n    const { minimum, maximum } = getMinMax({ min, max });\n\n    if (chunks.length === 0 && minimum === 0) {\n      // no chunks left, but this specifier does not require any items\n      continue; // eslint-disable-line no-continue\n    }\n\n    const arrayOfValidator = arrayOf(validator).isRequired;\n\n    const chunk = chunks.shift(); // extract the next chunk to test\n\n    const chunkError = arrayOfValidator(\n      { ...props, [propName]: chunk },\n      propName,\n      componentName,\n      ...rest,\n    );\n\n    if (chunkError) { // this chunk is invalid\n      if (minimum === 0) { // but, specifier has a min of 0 and can be skipped\n        chunks.unshift(chunk); // put the chunk back, for the next iteration\n        continue; // eslint-disable-line no-continue\n      }\n      return chunkError;\n    }\n\n    // chunk is valid!\n\n    if (chunk.length < minimum) {\n      return new RangeError(`${componentName}: specifier index ${i} requires a minimum of ${min} items, but only has ${chunk.length}.`);\n    }\n\n    if (chunk.length > maximum) {\n      return new RangeError(`${componentName}: specifier index ${i} requires a maximum of ${max} items, but has ${chunk.length}.`);\n    }\n  }\n\n  if (chunks.length > 0) {\n    return new TypeError(`${componentName}: after all ${specifiers.length} specifiers matched, ${chunks.length} types of items were remaining.`);\n  }\n\n  return null;\n}\n\nconst specifierValidator = withShape(object(), specifierShape).isRequired;\n\nexport default function sequenceOfValidator(...specifiers) {\n  if (specifiers.length === 0) {\n    throw new RangeError('sequenceOf: at least one specifier is required');\n  }\n\n  const errors = specifiers.map((specifier, i) => specifierValidator(\n    { specifier },\n    'specifier',\n    'sequenceOf specifier',\n    `suequenceOf specifier, index ${i}`,\n    `specifier, index ${i}`,\n  ));\n  if (errors.some(Boolean)) {\n    throw new TypeError(`\n      sequenceOf: all specifiers must match the appropriate shape.\n\n      Errors:\n        ${errors.map((e, i) => ` - Argument index ${i}: ${e.message}`).join(',\\n        ')}\n    `);\n  }\n\n  const validator = function sequenceOf(props, propName, ...rest) {\n    const { [propName]: propValue } = props;\n\n    if (propValue == null) {\n      return null;\n    }\n\n    const error = array(props, propName, ...rest);\n    if (error) {\n      return error;\n    }\n\n    return validateChunks(specifiers, props, propName, ...rest);\n  };\n\n  validator.isRequired = function sequenceOfRequired(props, propName, componentName, ...rest) {\n    const error = array.isRequired(props, propName, componentName, ...rest);\n    if (error) {\n      return error;\n    }\n\n    return validateChunks(specifiers, props, propName, componentName, ...rest);\n  };\n\n  return wrapValidator(validator, 'sequenceOf', specifiers);\n}\n"]}},"hash":"116c0b030ef9f8bee571d41e04b407a5","cacheData":{"env":{}}}