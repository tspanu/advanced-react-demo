{"id":"../node_modules/airbnb-prop-types/build/componentWithName.js","dependencies":[{"name":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/componentWithName.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/tspanu/Code/react-course-projects/expensify-app/package.json","includedInParent":true,"mtime":1543309168837},{"name":"/Users/tspanu/Code/react-course-projects/expensify-app/.babelrc","includedInParent":true,"mtime":1543309084056},{"name":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/package.json","includedInParent":true,"mtime":1542929074985},{"name":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/.babelrc","includedInParent":true,"mtime":499162500000},{"name":"react","loc":{"line":6,"column":21},"parent":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/componentWithName.js","resolved":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/react/index.js"},{"name":"is-regex","loc":{"line":10,"column":23},"parent":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/componentWithName.js","resolved":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/is-regex/index.js"},{"name":"array.prototype.find","loc":{"line":14,"column":30},"parent":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/componentWithName.js","resolved":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/array.prototype.find/index.js"},{"name":"./helpers/getComponentName","loc":{"line":18,"column":32},"parent":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/componentWithName.js","resolved":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/helpers/getComponentName.js"},{"name":"./helpers/wrapValidator","loc":{"line":22,"column":29},"parent":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/componentWithName.js","resolved":"/Users/tspanu/Code/react-course-projects/expensify-app/node_modules/airbnb-prop-types/build/helpers/wrapValidator.js"}],"generated":{"js":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports['default'] = componentWithName;\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _isRegex = require('is-regex');\n\nvar _isRegex2 = _interopRequireDefault(_isRegex);\n\nvar _arrayPrototype = require('array.prototype.find');\n\nvar _arrayPrototype2 = _interopRequireDefault(_arrayPrototype);\n\nvar _getComponentName = require('./helpers/getComponentName');\n\nvar _getComponentName2 = _interopRequireDefault(_getComponentName);\n\nvar _wrapValidator = require('./helpers/wrapValidator');\n\nvar _wrapValidator2 = _interopRequireDefault(_wrapValidator);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\nfunction stripHOCs(fullName, namesOfHOCsToStrip) {\n  var innerName = fullName;\n  while (/\\([^()]*\\)/g.test(innerName)) {\n    var HOC = innerName;\n    var previousHOC = void 0;\n    do {\n      previousHOC = HOC;\n      HOC = previousHOC.replace(/\\([^()]*\\)/g, '');\n    } while (previousHOC !== HOC);\n\n    if (namesOfHOCsToStrip.indexOf(HOC) === -1) {\n      return innerName;\n    }\n    innerName = innerName.replace(RegExp('^' + String(HOC) + '\\\\(|\\\\)$', 'g'), '');\n  }\n  return innerName;\n}\n\nfunction hasName(name, namesOfHOCsToStrip, propValue, propName, componentName) {\n  for (var _len = arguments.length, rest = Array(_len > 5 ? _len - 5 : 0), _key = 5; _key < _len; _key++) {\n    rest[_key - 5] = arguments[_key];\n  }\n\n  if (Array.isArray(propValue)) {\n    return (0, _arrayPrototype2['default'])(propValue.map(function (item) {\n      return hasName.apply(undefined, [name, namesOfHOCsToStrip, item, propName, componentName].concat(rest));\n    }), Boolean) || null;\n  }\n\n  if (!_react2['default'].isValidElement(propValue)) {\n    return new TypeError(String(componentName) + '.' + String(propName) + ' is not a valid React element');\n  }\n\n  var type = propValue.type;\n\n  var componentNameFromType = (0, _getComponentName2['default'])(type);\n  var innerComponentName = namesOfHOCsToStrip.length > 0 ? stripHOCs(componentNameFromType, namesOfHOCsToStrip) : componentNameFromType;\n\n  if ((0, _isRegex2['default'])(name) && !name.test(innerComponentName)) {\n    return new TypeError('`' + String(componentName) + '.' + String(propName) + '` only accepts components matching the regular expression ' + String(name));\n  }\n\n  if (!(0, _isRegex2['default'])(name) && innerComponentName !== name) {\n    return new TypeError('`' + String(componentName) + '.' + String(propName) + '` only accepts components named ' + String(name) + ', got ' + String(innerComponentName));\n  }\n\n  return null;\n}\n\nfunction componentWithName(name) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof name !== 'string' && !(0, _isRegex2['default'])(name)) {\n    throw new TypeError('name must be a string or a regex');\n  }\n\n  var passedOptions = Object.keys(options);\n  if (passedOptions.length > 1 || passedOptions.length === 1 && passedOptions[0] !== 'stripHOCs') {\n    throw new TypeError('The only options supported are: \\u201CstripHOCs\\u201D, got: \\u201C' + String(passedOptions.join('”, “')) + '\\u201D');\n  }\n  var _options$stripHOCs = options.stripHOCs,\n      namesOfHOCsToStrip = _options$stripHOCs === undefined ? [] : _options$stripHOCs;\n\n\n  var allHOCNamesAreValid = namesOfHOCsToStrip.every(function (x) {\n    if (typeof x !== 'string' || /[()]/g.test(x)) {\n      return false;\n    }\n    return (/^(?:[a-z][a-zA-Z0-9]+|[A-Z][a-z][a-zA-Z0-9]+)$/.test(x)\n    );\n  });\n  if (!allHOCNamesAreValid) {\n    throw new TypeError('every provided HOC name must be a string with no parens, and in camelCase');\n  }\n\n  function componentWithNameValidator(props, propName, componentName) {\n    var propValue = props[propName];\n\n    if (props[propName] == null) {\n      return null;\n    }\n\n    for (var _len2 = arguments.length, rest = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n      rest[_key2 - 3] = arguments[_key2];\n    }\n\n    return hasName.apply(undefined, [name, namesOfHOCsToStrip, propValue, propName, componentName].concat(rest));\n  }\n\n  componentWithNameValidator.isRequired = function () {\n    function componentWithNameRequired(props, propName, componentName) {\n      var propValue = props[propName];\n\n      if (propValue == null) {\n        return new TypeError('`' + String(componentName) + '.' + String(propName) + '` requires at least one component named ' + String(name));\n      }\n\n      for (var _len3 = arguments.length, rest = Array(_len3 > 3 ? _len3 - 3 : 0), _key3 = 3; _key3 < _len3; _key3++) {\n        rest[_key3 - 3] = arguments[_key3];\n      }\n\n      return hasName.apply(undefined, [name, namesOfHOCsToStrip, propValue, propName, componentName].concat(rest));\n    }\n\n    return componentWithNameRequired;\n  }();\n\n  return (0, _wrapValidator2['default'])(componentWithNameValidator, 'componentWithName:' + String(name), name);\n}\n","map":{"version":3,"sources":["../src/componentWithName.js"],"names":["componentWithName","stripHOCs","fullName","namesOfHOCsToStrip","innerName","test","HOC","previousHOC","replace","indexOf","RegExp","hasName","name","propValue","propName","componentName","rest","Array","isArray","map","item","Boolean","React","isValidElement","TypeError","type","componentNameFromType","innerComponentName","length","options","passedOptions","Object","keys","join","allHOCNamesAreValid","every","x","componentWithNameValidator","props","isRequired","componentWithNameRequired"],"mappings":"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","file":"componentWithName.js","sourcesContent":["import React from 'react';\nimport isRegex from 'is-regex';\nimport find from 'array.prototype.find';\n\nimport getComponentName from './helpers/getComponentName';\nimport wrapValidator from './helpers/wrapValidator';\n\nfunction stripHOCs(fullName, namesOfHOCsToStrip) {\n  let innerName = fullName;\n  while ((/\\([^()]*\\)/g).test(innerName)) {\n    let HOC = innerName;\n    let previousHOC;\n    do {\n      previousHOC = HOC;\n      HOC = previousHOC.replace(/\\([^()]*\\)/g, '');\n    } while (previousHOC !== HOC);\n\n    if (namesOfHOCsToStrip.indexOf(HOC) === -1) {\n      return innerName;\n    }\n    innerName = innerName.replace(RegExp(`^${HOC}\\\\(|\\\\)$`, 'g'), '');\n  }\n  return innerName;\n}\n\nfunction hasName(name, namesOfHOCsToStrip, propValue, propName, componentName, ...rest) {\n  if (Array.isArray(propValue)) {\n    return find(\n      propValue.map(item => hasName(\n        name,\n        namesOfHOCsToStrip,\n        item,\n        propName,\n        componentName,\n        ...rest,\n      )),\n      Boolean,\n    ) || null;\n  }\n\n  if (!React.isValidElement(propValue)) {\n    return new TypeError(\n      `${componentName}.${propName} is not a valid React element`,\n    );\n  }\n\n  const { type } = propValue;\n  const componentNameFromType = getComponentName(type);\n  const innerComponentName = namesOfHOCsToStrip.length > 0\n    ? stripHOCs(componentNameFromType, namesOfHOCsToStrip)\n    : componentNameFromType;\n\n  if (isRegex(name) && !name.test(innerComponentName)) {\n    return new TypeError(\n      `\\`${componentName}.${propName}\\` only accepts components matching the regular expression ${name}`,\n    );\n  }\n\n  if (!isRegex(name) && innerComponentName !== name) {\n    return new TypeError(\n      `\\`${componentName}.${propName}\\` only accepts components named ${name}, got ${innerComponentName}`,\n    );\n  }\n\n  return null;\n}\n\nexport default function componentWithName(\n  name,\n  options = {},\n) {\n  if (typeof name !== 'string' && !isRegex(name)) {\n    throw new TypeError('name must be a string or a regex');\n  }\n\n  const passedOptions = Object.keys(options);\n  if (passedOptions.length > 1 || (passedOptions.length === 1 && passedOptions[0] !== 'stripHOCs')) {\n    throw new TypeError(`The only options supported are: “stripHOCs”, got: “${passedOptions.join('”, “')}”`);\n  }\n  const { stripHOCs: namesOfHOCsToStrip = [] } = options;\n\n  const allHOCNamesAreValid = namesOfHOCsToStrip.every((x) => {\n    if (typeof x !== 'string' || /[()]/g.test(x)) {\n      return false;\n    }\n    return /^(?:[a-z][a-zA-Z0-9]+|[A-Z][a-z][a-zA-Z0-9]+)$/.test(x);\n  });\n  if (!allHOCNamesAreValid) {\n    throw new TypeError('every provided HOC name must be a string with no parens, and in camelCase');\n  }\n\n  function componentWithNameValidator(props, propName, componentName, ...rest) {\n    const { [propName]: propValue } = props;\n    if (props[propName] == null) {\n      return null;\n    }\n    return hasName(name, namesOfHOCsToStrip, propValue, propName, componentName, ...rest);\n  }\n\n  componentWithNameValidator.isRequired = function componentWithNameRequired(\n    props,\n    propName,\n    componentName,\n    ...rest\n  ) {\n    const { [propName]: propValue } = props;\n    if (propValue == null) {\n      return new TypeError(`\\`${componentName}.${propName}\\` requires at least one component named ${name}`);\n    }\n    return hasName(name, namesOfHOCsToStrip, propValue, propName, componentName, ...rest);\n  };\n\n  return wrapValidator(componentWithNameValidator, `componentWithName:${name}`, name);\n}\n"]}},"hash":"e5059384c9cf4e0a9519c58b8000d15a","cacheData":{"env":{}}}